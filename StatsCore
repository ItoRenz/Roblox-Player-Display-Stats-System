-- ========================================
-- StatsCore.server.lua (ServerScript)
-- Author: ItoRenz00
-- Version: 1.1
-- ========================================
-- Features:
-- - Leaderstats + DataStore persistence
-- - Sequential checkpoint system (anti-skip)
-- - Summit tracking
-- - Self-healing checkpoint validation
-- - Automatic respawn to last checkpoint
-- - Multiple folder name support (CheckPoint/Checkpoint)
-- ========================================

local Players = game:GetService("Players")
local DataStoreService = game:GetService("DataStoreService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")

-- ========================================
-- CONFIGURATION
-- ========================================

local CONFIG = {
	SUMMIT_FOLDER_NAME = "Summit",
	TOUCH_COOLDOWN_SEC = 0.8,
	RESPAWN_TO_LAST_CP = true,
	TELEPORT_OFFSET = Vector3.new(0, 3, 0),
	DEBUG_LOG = false  -- Set true for detailed logs (Studio only)
}

local function dprint(...)
	if CONFIG.DEBUG_LOG and RunService:IsStudio() then
		print("[StatsCore]", ...)
	end
end

-- ========================================
-- DATASTORE SETUP
-- ========================================

local SummitStore = DataStoreService:GetDataStore("SummitStore_V4")

-- ========================================
-- UTILITY FUNCTIONS
-- ========================================

local function coalesce(ls: Instance, canonical: string, aliases: {string})
	local keeper = ls:FindFirstChild(canonical)
	local dupes = {}

	for _, alias in ipairs(aliases or {}) do
		local v = ls:FindFirstChild(alias)
		if v and v:IsA("IntValue") then
			table.insert(dupes, v)
		end
	end

	if not keeper then
		if #dupes > 0 then
			keeper = dupes[1]
		else
			keeper = Instance.new("IntValue")
			keeper.Name = canonical
			keeper.Value = 0
			keeper.Parent = ls
		end
	end

	for _, iv in ipairs(dupes) do
		if iv ~= keeper then
			if iv.Value > keeper.Value then
				keeper.Value = iv.Value
			end
			iv:Destroy()
		end
	end

	keeper.Name = canonical
	return keeper
end

local function parseCpIndex(name: string?): number?
	if not name then
		return nil
	end
	
	local n = string.lower(name)
	local idx = n:match("^cp%s*[_%-]?%s*(%d+)$")
		or n:match("^checkpoint%s*[_%-]?%s*(%d+)$")
		or n:match("(%d+)$")
		
	return idx and tonumber(idx) or nil
end

local function getPlayerFromHit(hit: BasePart?)
	if not hit then
		return nil
	end
	
	local char = hit:FindFirstAncestorOfClass("Model")
	if not char then
		return nil
	end
	
	local hum = char:FindFirstChildOfClass("Humanoid")
	if not hum then
		return nil
	end
	
	return Players:GetPlayerFromCharacter(char), char
end

-- ========================================
-- PLAYER STATE MANAGEMENT
-- ========================================

local runState: {[Player]: {active: boolean, nextIdx: number, debounce: {[Instance]: number}}} = {}

local function ensureState(p: Player)
	runState[p] = runState[p] or {
		active = false,
		nextIdx = 1,
		debounce = {}
	}
	return runState[p]
end

local function clearState(p: Player)
	runState[p] = {
		active = false,
		nextIdx = 1,
		debounce = {}
	}
end

local function canTouch(p: Player, key: Instance, cooldown: number)
	local st = ensureState(p)
	local now = os.clock()
	local last = st.debounce[key] or 0

	if now - last < (cooldown or CONFIG.TOUCH_COOLDOWN_SEC) then
		return false
	end

	st.debounce[key] = now
	return true
end

-- ========================================
-- CHECKPOINT & SUMMIT REGISTRATION
-- ========================================

local cpIndexByPart = setmetatable({}, {__mode = "k"}) :: {[Instance]: number}
local isSummitPartByPart = setmetatable({}, {__mode = "k"}) :: {[Instance]: boolean}

local lastResyncAt = 0

local function resyncAllPlayersDebounced()
	local now = os.clock()
	if now - lastResyncAt < 0.5 then
		return
	end
	lastResyncAt = now

	task.defer(function()
		for _, p in ipairs(Players:GetPlayers()) do
			local st = ensureState(p)
			local ls = p:FindFirstChild("leaderstats")
			local cp = ls and ls:FindFirstChild("Checkpoint")
			local v = (cp and cp:IsA("IntValue")) and cp.Value or 0
			
			st.active = (v > 0)
			st.nextIdx = math.max(1, v + 1)
		end
	end)
end

local function registerCheckpointPart(part: BasePart)
	pcall(function()
		part.CanTouch = true
	end)

	local idx = parseCpIndex(part.Name)
	if not idx and part.Parent then
		idx = parseCpIndex(part.Parent.Name)
	end
	
	cpIndexByPart[part] = idx

	if part.Parent and idx and cpIndexByPart[part.Parent] == nil then
		cpIndexByPart[part.Parent] = idx
	end

	resyncAllPlayersDebounced()
end

local function registerSummitPart(part: BasePart)
	pcall(function()
		part.CanTouch = true
	end)

	isSummitPartByPart[part] = true
	
	if part.Parent and isSummitPartByPart[part.Parent] == nil then
		isSummitPartByPart[part.Parent] = true
	end

	resyncAllPlayersDebounced()
end

local function getMaxCpIndex(): number
	local max = 0
	for inst, idx in pairs(cpIndexByPart) do
		if typeof(inst) == "Instance" and idx and idx > max then
			max = idx
		end
	end
	return max
end

-- ========================================
-- CHECKPOINT & SUMMIT LOGIC
-- ========================================

local function handleCheckpointHit(player: Player, idx: number, key: Instance)
	if not idx then
		return
	end
	
	if not canTouch(player, key, CONFIG.TOUCH_COOLDOWN_SEC) then
		return
	end

	local ls = player:FindFirstChild("leaderstats")
	if not ls then
		return
	end

	local cpVal = ls:FindFirstChild("Checkpoint")
	if not (cpVal and cpVal:IsA("IntValue")) then
		return
	end

	local need = cpVal.Value + 1
	if idx == need then
		cpVal.Value = idx
		local st = ensureState(player)
		st.active = true
		st.nextIdx = idx + 1
		
		dprint(("‚úì CP %d reached by %s"):format(idx, player.Name))
	else
		dprint(("‚úó CP %d skipped by %s (needed=%d)"):format(idx, player.Name, need))
	end
end

local function handleSummitHit(player: Player, key: Instance)
	if not canTouch(player, key, 1.0) then
		return
	end

	local ls = player:FindFirstChild("leaderstats")
	if not ls then
		return
	end

	local summit = ls:FindFirstChild("Summit")
	local cp = ls:FindFirstChild("Checkpoint")
	
	if not (summit and cp and summit:IsA("IntValue") and cp:IsA("IntValue")) then
		return
	end

	local maxIdx = getMaxCpIndex()
	if maxIdx <= 0 then
		return
	end

	if cp.Value > maxIdx then
		dprint(("Clamp CP %s from %d -> %d"):format(player.Name, cp.Value, maxIdx))
		cp.Value = maxIdx
	end

	if cp.Value == maxIdx then
		summit.Value += 1
		cp.Value = 0

		local st = ensureState(player)
		st.active = false
		st.nextIdx = 1
		st.debounce = {}

		dprint(("üèÜ SUMMIT! %s (Total: %d)"):format(player.Name, summit.Value))
	else
		dprint(("‚úó Summit failed for %s (cp=%d, need=%d)"):format(player.Name, cp.Value, maxIdx))
	end
end

-- ========================================
-- PART HOOKING
-- ========================================

local function hookCheckpointPart(part: BasePart)
	if not part:IsA("BasePart") or part:GetAttribute("CPHooked") then
		return
	end
	
	part:SetAttribute("CPHooked", true)
	registerCheckpointPart(part)

	part.Touched:Connect(function(hit)
		local player = getPlayerFromHit(hit)
		if not player then
			return
		end
		
		local idx = parseCpIndex(part.Name) or (part.Parent and parseCpIndex(part.Parent.Name))
		handleCheckpointHit(player, idx, part)
	end)
end

local function hookSummitPart(part: BasePart)
	if not part:IsA("BasePart") or part:GetAttribute("SummitHooked") then
		return
	end
	
	part:SetAttribute("SummitHooked", true)
	registerSummitPart(part)

	part.Touched:Connect(function(hit)
		local player = getPlayerFromHit(hit)
		if not player then
			return
		end
		
		handleSummitHit(player, part)
	end)
end

local function hookCharacterTouchers(p: Player, char: Model)
	local hrp = char:WaitForChild("HumanoidRootPart", 10)
	if not hrp then
		return
	end

	pcall(function()
		hrp.CanTouch = true
	end)

	hrp.Touched:Connect(function(hit)
		if not hit or not hit:IsA("BasePart") then
			return
		end

		local inst = hit
		local idx, isSummit

		while inst and inst ~= Workspace do
			idx = cpIndexByPart[inst]
			isSummit = isSummitPartByPart[inst]
			
			if idx or isSummit then
				break
			end
			
			inst = inst.Parent
		end

		if idx then
			handleCheckpointHit(p, idx, inst or hit)
		elseif isSummit then
			handleSummitHit(p, inst or hit)
		end
	end)
end

-- ========================================
-- FOLDER SCANNING & INITIALIZATION
-- ========================================

local function scanFolder(name: string, callback)
	local folder = Workspace:FindFirstChild(name)
	if not folder then
		dprint(("‚ö† Workspace/%s not found"):format(name))
		return
	end

	if folder:IsA("BasePart") then
		callback(folder)
	end

	for _, descendant in ipairs(folder:GetDescendants()) do
		if descendant:IsA("BasePart") then
			callback(descendant)
		end
	end

	folder.DescendantAdded:Connect(function(descendant)
		if descendant:IsA("BasePart") then
			callback(descendant)
		end
	end)
end

scanFolder("CheckPoint", hookCheckpointPart)
scanFolder("Checkpoint", hookCheckpointPart)
scanFolder(CONFIG.SUMMIT_FOLDER_NAME, hookSummitPart)

-- ========================================
-- RESPAWN TO CHECKPOINT
-- ========================================

local function getCpCFrame(index: number): CFrame?
	if not index or index <= 0 then
		return nil
	end

	for inst, idx in pairs(cpIndexByPart) do
		if typeof(inst) == "Instance" and idx == index and inst:IsA("BasePart") then
			return inst.CFrame
		end
	end

	return nil
end

local function onCharacterAdded(p: Player, char: Model)
	ensureState(p)
	hookCharacterTouchers(p, char)

	local st = ensureState(p)
	local ls = p:FindFirstChild("leaderstats")
	local cpv = ls and ls:FindFirstChild("Checkpoint")
	local v = (cpv and cpv:IsA("IntValue")) and cpv.Value or 0
	
	st.active = (v > 0)
	st.nextIdx = math.max(1, v + 1)

	if not CONFIG.RESPAWN_TO_LAST_CP then
		return
	end
	
	if not (cpv and cpv.Value > 0) then
		return
	end

	local cf = getCpCFrame(cpv.Value)
	if cf then
		task.defer(function()
			local root = char:WaitForChild("HumanoidRootPart", 10)
			if root then
				char:PivotTo(cf + CONFIG.TELEPORT_OFFSET)
				dprint(("‚Ü∫ Respawned %s to CP %d"):format(p.Name, cpv.Value))
			end
		end)
	end
end

-- ========================================
-- LEADERSTATS & DATASTORE
-- ========================================

local function setupLeaderstats(plr: Player)
	local ls = plr:FindFirstChild("leaderstats")
	if not ls then
		ls = Instance.new("Folder")
		ls.Name = "leaderstats"
		ls.Parent = plr
	end

	local summit = coalesce(ls, "Summit", {"summit", "SUMMIT"})
	local checkpoint = coalesce(ls, "Checkpoint", {"CheckPoint", "checkpoint", "CHECKPOINT"})

	task.spawn(function()
		local ok, saved = pcall(function()
			return SummitStore:GetAsync(("U_%d"):format(plr.UserId))
		end)

		if ok and typeof(saved) == "table" then
			if tonumber(saved.summit) then
				summit.Value = tonumber(saved.summit)
			end
			if tonumber(saved.checkpoint) then
				checkpoint.Value = tonumber(saved.checkpoint)
			end
		elseif ok and typeof(saved) == "number" then
			summit.Value = saved
		end

		local mx = getMaxCpIndex()
		if mx > 0 and checkpoint.Value > mx then
			dprint(("Clamp CP on load %s: %d -> %d"):format(plr.Name, checkpoint.Value, mx))
			checkpoint.Value = mx
		end

		task.defer(function()
			local st = ensureState(plr)
			local v = checkpoint.Value
			st.active = (v > 0)
			st.nextIdx = math.max(1, v + 1)
		end)
	end)

	local function save()
		task.spawn(function()
			pcall(function()
				SummitStore:SetAsync(
					("U_%d"):format(plr.UserId),
					{
						summit = summit.Value,
						checkpoint = checkpoint.Value,
					}
				)
			end)
		end)
	end

	summit:GetPropertyChangedSignal("Value"):Connect(save)
	checkpoint:GetPropertyChangedSignal("Value"):Connect(save)

	checkpoint:GetPropertyChangedSignal("Value"):Connect(function()
		local st = ensureState(plr)
		local v = checkpoint.Value
		st.active = (v > 0)
		st.nextIdx = math.max(1, v + 1)
	end)
end

-- ========================================
-- PLAYER EVENT HANDLERS
-- ========================================

Players.PlayerAdded:Connect(function(p)
	setupLeaderstats(p)
	
	p.CharacterAdded:Connect(function(char)
		onCharacterAdded(p, char)
	end)
	
	if p.Character then
		onCharacterAdded(p, p.Character)
	end
end)

for _, p in ipairs(Players:GetPlayers()) do
	setupLeaderstats(p)
	
	p.CharacterAdded:Connect(function(char)
		onCharacterAdded(p, char)
	end)
	
	if p.Character then
		onCharacterAdded(p, p.Character)
	end
end

Players.PlayerRemoving:Connect(function(plr)
	local ls = plr:FindFirstChild("leaderstats")
	local s = ls and ls:FindFirstChild("Summit")
	local c = ls and ls:FindFirstChild("Checkpoint")

	pcall(function()
		SummitStore:SetAsync(
			("U_%d"):format(plr.UserId),
			{
				summit = s and s.Value or 0,
				checkpoint = c and c.Value or 0,
			}
		)
	end)

	runState[plr] = nil
end)

-- ========================================
-- INITIALIZATION
-- ========================================

print("========================================")
print("‚úÖ StatsCore Server Ready")
print("üë§ Author: ItoRenz00")
print("========================================")
